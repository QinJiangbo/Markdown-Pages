---
title: 设计模式学习之抽象工厂模式
date: 2016-12-05 00:50:24
thumbnail: https://obrxbqjbi.qnssl.com/blog/image/desgin-patterns/abstract-factory.png
tags:
	- 抽象工厂模式
	- 设计模式
categories:
	- 设计模式
keywords:
	- 抽象工厂模式
	- 设计模式
---
## 什么是抽象工厂模式
**抽象工厂模式（Abstract Factory Design Pattern）**`提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类`。

## 是时候使用抽象工厂模式啦
抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或者关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。

## 抽象工厂模式类图
![抽象工厂模式类图](https://obrxbqjbi.qnssl.com/blog/image/desgin-patterns/abstract-factory-01.png)

`Client`客户的代码中只需要涉及抽象工厂，运行时将使用实际的工厂。

`AbstractFactory`抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口中包含一组方法用来生产产品。

`ConcreteFactory`具体工厂实现不同的产品家族，要创建一个产品，客户完全不需要知道产品是如何创建的，它只需要使用其中的一个具体工厂即可。

 `AbstractProduct`是抽象产品类，是所有具体产品类必须实现的类。`AbstractProductA`和`AbstractProductB`形成了一个产品族。每个具体工厂类都能产生一整组的产品。
 
## 实例分析-调料工厂
前面我们说了这个披萨店的问题，发现不同的披萨店可以生产不同的披萨，但是为什么披萨的口味会不同呢？答案当然是调料不一样啦。那么纽约风味的披萨店和芝加哥风味的披萨店他们的调料从哪儿来呢？这里可以很容易的想到，从两个不同城市的工厂直接就近运输过来。所以是两个工厂来生产这个调料。
 
### 调料工厂的类图
![调料工厂的类图](https://obrxbqjbi.qnssl.com/blog/image/desgin-patterns/abstract-factory-02.png)

哇！好复杂的图！别急，骚年~仔细一看其实还是很简单滴~这个类图待我慢慢给你解释。

首先对照上面的抽象工厂模式类图，我们会发现，披萨店的两个具体实例（`NYPizzaStore`和`ChicagoPizzaStore`）就是抽象工厂的客户。图中给出的是`NYPizzaStore`，大概是因为它做出来的东西好吃吧。

其次我们会发现原料工厂`PizzaingredientFactory`，这是一个原料工厂接口，它定义了如何产生一组相关产品的家族。这个家族包含了所有制作披萨的原料。下面两个`NYPizzaingredientFactory`和`ChicagoingredientFactory`则是这个接口的两个具体实现工厂，这两个具体工厂专门负责生产披萨的原料，每个工厂都知道如何去生产符合本地区口味的原料。对于这个产品家族，每个原料工厂都有自己不同的实现。

## 工厂方法模式 VS 抽象工厂模式
### 主要有以下两点不同：
 
1. **工厂方法使用类创建对象；抽象工厂使用对象来创建对象。**这里有点绕，说白了，工厂方法模式下面时直接调用的类方法（也叫静态工厂方法）创建对象，而抽象工厂则是传递一个具体工厂实例，通过这个具体工厂实例去创建对象。
2. **工厂方法创建的是一个产品；而抽象工厂创建的是一个产品家族。**

## 工厂方法是否包含在抽象工厂里面
**是的！**抽象工厂的任务是需要定一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品。同时我们利用实现抽象工厂的子类来实现这些具体的做法。所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。

## 总结
关于抽象工厂的代码实现就不写啦，因为大部分和上一篇博客（设计模式学习之工厂方法模式）比较像，所以本次我们只讨论设计模型本身，不讨论具体代码的实现。相信小伙伴们都能自己实现的出来。抽象工厂里面有一个非常重要的原则就是`依赖倒置原则`，这个原则指导我们`避免依赖具体类型而应该依赖抽象`。

设计模式GitHub仓库地址：[https://github.com/QinJiangbo/DesignPatterns](https://github.com/QinJiangbo/DesignPatterns)